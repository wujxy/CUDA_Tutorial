#include "../include/visualization.h"
#include "../include/config.h"
#include <fstream>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef _WIN32
#include <direct.h>
#define mkdir(path, mode) _mkdir(path)
#endif

/**
 * 构造函数
 */
Visualizer::Visualizer(const std::string& output_dir) : output_dir(output_dir) {
}

/**
 * 创建输出目录
 */
bool Visualizer::createOutputDirectory() {
#ifdef _WIN32
    int ret = _mkdir(output_dir.c_str());
#else
    int ret = mkdir(output_dir.c_str(), 0755);
#endif
    if (ret == 0) {
        std::cout << "Created output directory: " << output_dir << std::endl;
        return true;
    } else {
        // 目录可能已存在
        return true;
    }
}

/**
 * 投影2D直方图到X方向
 */
Projection1D Visualizer::projectToX(const Histogram2D& hist) {
    Projection1D proj;
    proj.nbins = hist.nx;
    proj.min_val = hist.x_min;
    proj.max_val = hist.x_max;
    proj.bin_centers.resize(hist.nx);
    proj.counts.resize(hist.nx, 0);

    float dx = (hist.x_max - hist.x_min) / hist.nx;

    // 计算bin中心
    for (int i = 0; i < hist.nx; i++) {
        proj.bin_centers[i] = hist.x_min + (i + 0.5f) * dx;
    }

    // 投影：对每列求和
    for (int iy = 0; iy < hist.ny; iy++) {
        for (int ix = 0; ix < hist.nx; ix++) {
            int idx = iy * hist.nx + ix;
            proj.counts[ix] += hist.data[idx];
        }
    }

    return proj;
}

/**
 * 投影2D直方图到Y方向
 */
Projection1D Visualizer::projectToY(const Histogram2D& hist) {
    Projection1D proj;
    proj.nbins = hist.ny;
    proj.min_val = hist.y_min;
    proj.max_val = hist.y_max;
    proj.bin_centers.resize(hist.ny);
    proj.counts.resize(hist.ny, 0);

    float dy = (hist.y_max - hist.y_min) / hist.ny;

    // 计算bin中心
    for (int i = 0; i < hist.ny; i++) {
        proj.bin_centers[i] = hist.y_min + (i + 0.5f) * dy;
    }

    // 投影：对每行求和
    for (int iy = 0; iy < hist.ny; iy++) {
        for (int ix = 0; ix < hist.nx; ix++) {
            int idx = iy * hist.nx + ix;
            proj.counts[iy] += hist.data[idx];
        }
    }

    return proj;
}

/**
 * 计算1D高斯分布曲线
 * 对于2D高斯 N(x,y)的边缘分布:
 * p(x) = integral N(x,y) dy ~ N(x; x0, sigma_x)
 *
 * 关键：曲线需要和observed直方图对齐
 * - observed: 实际落在每个bin中的counts
 * - curve: 模型预测的每个bin中的期望counts
 */
std::vector<float> Visualizer::compute1DGaussianCurve(
    const Projection1D& proj,
    float mean,
    float sigma,
    float total_counts
) {
    std::vector<float> curve(proj.nbins);
    float bin_width = (proj.max_val - proj.min_val) / proj.nbins;

    // 1D高斯归一化因子（使得PDF在无限域上积分为1）
    float norm_factor = 1.0f / (sigma * sqrtf(2.0f * 3.14159265359f));

    for (int i = 0; i < proj.nbins; i++) {
        float x = proj.bin_centers[i];
        float z = (x - mean) / sigma;
        // 计算PDF值（概率密度）
        float pdf = norm_factor * expf(-0.5f * z * z);
        // 转换为期望counts：
        // expected_counts = PDF * bin_width * total_counts
        // 这给出的是"在这个bin中预期的样本数"
        curve[i] = pdf * bin_width * total_counts;
    }

    return curve;
}

/**
 * 保存配置信息到文件
 */
bool Visualizer::saveConfig(const std::string& output_path, const Config& config) {
    std::ofstream file(output_path);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << output_path << std::endl;
        return false;
    }

    file << "# Configuration File\n";
    file << "# Generated by CUDA 2D Gaussian Fitter\n\n";

    file << "[true_params]\n";
    file << "A = " << config.true_params.A << "\n";
    file << "x0 = " << config.true_params.x0 << "\n";
    file << "y0 = " << config.true_params.y0 << "\n";
    file << "sigma_x = " << config.true_params.sigma_x << "\n";
    file << "sigma_y = " << config.true_params.sigma_y << "\n";
    file << "rho = " << config.true_params.rho << "\n\n";

    file << "[histogram]\n";
    file << "nx = " << config.nx << "\n";
    file << "ny = " << config.ny << "\n";
    file << "x_min = " << config.x_min << "\n";
    file << "x_max = " << config.x_max << "\n";
    file << "y_min = " << config.y_min << "\n";
    file << "y_max = " << config.y_max << "\n";
    file << "num_samples = " << config.num_samples << "\n\n";

    file << "[initial_guess]\n";
    file << "A = " << config.initial_guess.A << "\n";
    file << "x0 = " << config.initial_guess.x0 << "\n";
    file << "y0 = " << config.initial_guess.y0 << "\n";
    file << "sigma_x = " << config.initial_guess.sigma_x << "\n";
    file << "sigma_y = " << config.initial_guess.sigma_y << "\n";
    file << "rho = " << config.initial_guess.rho << "\n\n";

    file << "[optimizer]\n";
    file << "learning_rate = " << config.learning_rate << "\n";
    file << "max_iterations = " << config.max_iterations << "\n";
    file << "tolerance = " << config.tolerance << "\n";
    file << "gradient_epsilon = " << config.gradient_epsilon << "\n";
    file << "verbose = " << (config.verbose ? "true" : "false") << "\n";

    file.close();
    std::cout << "Saved config to: " << output_path << std::endl;
    return true;
}

/**
 * 保存优化结果到文件
 */
bool Visualizer::saveResults(const std::string& output_path,
                             const OptimizationResult& result,
                             const GaussianParams& true_params) {
    std::ofstream file(output_path);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << output_path << std::endl;
        return false;
    }

    file << "# Optimization Results\n";
    file << "# Generated by CUDA 2D Gaussian Fitter\n\n";

    file << "=== True Parameters ===\n";
    file << "A = " << true_params.A << "\n";
    file << "x0 = " << true_params.x0 << "\n";
    file << "y0 = " << true_params.y0 << "\n";
    file << "sigma_x = " << true_params.sigma_x << "\n";
    file << "sigma_y = " << true_params.sigma_y << "\n";
    file << "rho = " << true_params.rho << "\n\n";

    file << "=== Fitted Parameters ===\n";
    file << "A = " << result.params.A << "\n";
    file << "x0 = " << result.params.x0 << "\n";
    file << "y0 = " << result.params.y0 << "\n";
    file << "sigma_x = " << result.params.sigma_x << "\n";
    file << "sigma_y = " << result.params.sigma_y << "\n";
    file << "rho = " << result.params.rho << "\n\n";

    file << "=== Errors (% ) ===\n";
    auto calcError = [](float true_val, float fit_val) -> float {
        return (fit_val - true_val) / true_val * 100.0f;
    };
    file << "A_error = " << calcError(true_params.A, result.params.A) << "\n";
    file << "x0_error = " << calcError(true_params.x0, result.params.x0) << "\n";
    file << "y0_error = " << calcError(true_params.y0, result.params.y0) << "\n";
    file << "sigma_x_error = " << calcError(true_params.sigma_x, result.params.sigma_x) << "\n";
    file << "sigma_y_error = " << calcError(true_params.sigma_y, result.params.sigma_y) << "\n";
    file << "rho_error = " << calcError(true_params.rho, result.params.rho) << "\n\n";

    file << "=== Optimization Summary ===\n";
    file << "final_likelihood = " << result.final_likelihood << "\n";
    file << "iterations = " << result.iterations << "\n";
    file << "converged = " << (result.converged ? "true" : "false") << "\n";

    if (!result.iteration_times.empty()) {
        float total_time = 0.0f;
        for (float t : result.iteration_times) {
            total_time += t;
        }
        file << "avg_iteration_time_ms = " << (total_time / result.iteration_times.size()) << "\n";
        file << "total_time_ms = " << total_time << "\n";
    }

    file.close();
    std::cout << "Saved results to: " << output_path << std::endl;
    return true;
}

/**
 * 保存性能数据（迭代时间）到CSV
 */
bool Visualizer::saveTimingData(const std::string& output_path,
                                const std::vector<float>& iteration_times,
                                int save_interval) {
    std::ofstream file(output_path);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << output_path << std::endl;
        return false;
    }

    file << "iteration,time_ms\n";

    for (size_t i = 0; i < iteration_times.size(); i++) {
        file << (i + 1) << "," << iteration_times[i] << "\n";
    }

    file.close();
    std::cout << "Saved timing data to: " << output_path << std::endl;
    return true;
}

/**
 * 绘制1维直方图和拟合曲线
 */
bool Visualizer::plot1DHistogramWithFit(
    const Histogram2D& hist,
    const GaussianParams& fit_params,
    const GaussianParams& true_params
) {
    // 获取投影数据
    Projection1D proj_x = projectToX(hist);
    Projection1D proj_y = projectToY(hist);

    // 计算总counts（使用实际观测的总counts，而不是参数中的A）
    int total_counts = 0;
    for (int i = 0; i < hist.nx * hist.ny; i++) {
        total_counts += hist.data[i];
    }

    // 计算拟合曲线（使用实际总counts进行归一化）
    std::vector<float> fit_curve_x = compute1DGaussianCurve(proj_x, fit_params.x0, fit_params.sigma_x, total_counts);
    std::vector<float> fit_curve_y = compute1DGaussianCurve(proj_y, fit_params.y0, fit_params.sigma_y, total_counts);

    // 保存X方向数据
    std::string x_data_path = output_dir + "/histogram_x_data.csv";
    std::ofstream fx(x_data_path);
    if (fx.is_open()) {
        fx << "bin_center,observed,fit_curve\n";
        for (int i = 0; i < proj_x.nbins; i++) {
            fx << proj_x.bin_centers[i] << ","
               << proj_x.counts[i] << ","
               << fit_curve_x[i] << "\n";
        }
        fx.close();
    }

    // 保存Y方向数据
    std::string y_data_path = output_dir + "/histogram_y_data.csv";
    std::ofstream fy(y_data_path);
    if (fy.is_open()) {
        fy << "bin_center,observed,fit_curve\n";
        for (int i = 0; i < proj_y.nbins; i++) {
            fy << proj_y.bin_centers[i] << ","
               << proj_y.counts[i] << ","
               << fit_curve_y[i] << "\n";
        }
        fy.close();
    }

    std::cout << "Saved histogram projection data to: " << x_data_path << " and " << y_data_path << std::endl;
    return true;
}

/**
 * 绘制2D直方图热图
 */
bool Visualizer::plot2DHistogram(const Histogram2D& hist) {
    std::string path = output_dir + "/histogram_2d_data.csv";
    std::ofstream file(path);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << path << std::endl;
        return false;
    }

    // 写入头部
    file << "x,y,count\n";

    float dx = (hist.x_max - hist.x_min) / hist.nx;
    float dy = (hist.y_max - hist.y_min) / hist.ny;

    // 写入每个bin的数据
    for (int iy = 0; iy < hist.ny; iy++) {
        for (int ix = 0; ix < hist.nx; ix++) {
            int idx = iy * hist.nx + ix;
            float x = hist.x_min + (ix + 0.5f) * dx;
            float y = hist.y_min + (iy + 0.5f) * dy;
            file << x << "," << y << "," << hist.data[idx] << "\n";
        }
    }

    file.close();
    std::cout << "Saved 2D histogram data to: " << path << std::endl;
    return true;
}

/**
 * 绘制迭代时间曲线
 */
bool Visualizer::plotIterationTimes(
    const std::vector<float>& iteration_times,
    int save_interval
) {
    std::string path = output_dir + "/iteration_times.csv";
    return saveTimingData(path, iteration_times, save_interval);
}

/**
 * 绘制似然值变化曲线
 */
bool Visualizer::plotLikelihoodHistory(
    const std::vector<float>& likelihood_history
) {
    std::string path = output_dir + "/likelihood_history.csv";
    std::ofstream file(path);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open file for writing: " << path << std::endl;
        return false;
    }

    file << "iteration,likelihood\n";
    for (size_t i = 0; i < likelihood_history.size(); i++) {
        file << (i + 1) << "," << likelihood_history[i] << "\n";
    }

    file.close();
    std::cout << "Saved likelihood history to: " << path << std::endl;
    return true;
}

/**
 * 生成并保存所有输出
 */
bool Visualizer::generateAllOutputs(
    const Histogram2D& hist,
    const OptimizationResult& result,
    const GaussianParams& true_params,
    const Config& config
) {
    // 创建输出目录
    createOutputDirectory();

    std::cout << "\n=== Generating Output Files ===" << std::endl;

    // 保存配置
    saveConfig(output_dir + "/config.txt", config);

    // 保存结果
    saveResults(output_dir + "/results.txt", result, true_params);

    // 绘制1D直方图
    plot1DHistogramWithFit(hist, result.params, true_params);

    // 绘制2D直方图
    plot2DHistogram(hist);

    // 绘制迭代时间
    if (!result.iteration_times.empty()) {
        plotIterationTimes(result.iteration_times, config.timing_save_interval);
    }

    // 绘制似然历史
    if (!result.likelihood_history.empty()) {
        plotLikelihoodHistory(result.likelihood_history);
    }

    // 生成Python绘图脚本
    std::string script_path = output_dir + "/plot_results.py";
    std::ofstream script(script_path);
    if (script.is_open()) {
        script << R"(#!/usr/bin/env python3
"""
Generate plots from CUDA Gaussian Fitter output
"""
import numpy as np
import matplotlib.pyplot as plt
import os

# 设置输出目录
output_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(output_dir)

# 设置图像风格
plt.style.use('seaborn-v0_8-darkgrid')
plt.rcParams['figure.dpi'] = 100
plt.rcParams['savefig.dpi'] = 300
plt.rcParams['font.size'] = 10

# ============================================
# 1. X方向直方图 + 拟合曲线
# ============================================
print("Plotting X histogram...")
data_x = np.loadtxt('histogram_x_data.csv', delimiter=',', skiprows=1)
bin_centers = data_x[:, 0]
observed = data_x[:, 1]
fit_curve = data_x[:, 2]

fig, ax = plt.subplots(figsize=(8, 5))
ax.bar(bin_centers, observed, width=(bin_centers[1]-bin_centers[0])*0.8,
       alpha=0.6, label='Observed', color='steelblue', edgecolor='black')
ax.plot(bin_centers, fit_curve, 'r-', linewidth=2, label='Fitted', alpha=0.8)
ax.set_xlabel('X')
ax.set_ylabel('Counts')
ax.set_title('X Distribution: Histogram vs Fitted Gaussian')
ax.legend()
plt.tight_layout()
plt.savefig('histogram_x.jpg', format='jpg', bbox_inches='tight')
plt.close()
print("Saved: histogram_x.jpg")

# ============================================
# 2. Y方向直方图 + 拟合曲线
# ============================================
print("Plotting Y histogram...")
data_y = np.loadtxt('histogram_y_data.csv', delimiter=',', skiprows=1)
bin_centers = data_y[:, 0]
observed = data_y[:, 1]
fit_curve = data_y[:, 2]

fig, ax = plt.subplots(figsize=(8, 5))
ax.bar(bin_centers, observed, width=(bin_centers[1]-bin_centers[0])*0.8,
       alpha=0.6, label='Observed', color='steelblue', edgecolor='black')
ax.plot(bin_centers, fit_curve, 'r-', linewidth=2, label='Fitted', alpha=0.8)
ax.set_xlabel('Y')
ax.set_ylabel('Counts')
ax.set_title('Y Distribution: Histogram vs Fitted Gaussian')
ax.legend()
plt.tight_layout()
plt.savefig('histogram_y.jpg', format='jpg', bbox_inches='tight')
plt.close()
print("Saved: histogram_y.jpg")

# ============================================
# 3. 2D直方图热图
# ============================================
print("Plotting 2D histogram...")
data_2d = np.loadtxt('histogram_2d_data.csv', delimiter=',', skiprows=1)
x = data_2d[:, 0]
y = data_2d[:, 1]
counts = data_2d[:, 2]

# 获取原始bin数量
nx = len(np.unique(x))
ny = len(np.unique(y))

# 重塑为2D数组
x_unique = np.unique(x)
y_unique = np.unique(y)
counts_2d = counts.reshape(len(y_unique), len(x_unique))

fig, ax = plt.subplots(figsize=(8, 7))
im = ax.pcolormesh(x_unique, y_unique, counts_2d, shading='auto', cmap='viridis')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_title('2D Gaussian Histogram')
cbar = plt.colorbar(im, ax=ax)
cbar.set_label('Counts')
plt.tight_layout()
plt.savefig('histogram_2d.jpg', format='jpg', bbox_inches='tight')
plt.close()
print("Saved: histogram_2d.jpg")

# ============================================
# 4. 迭代时间曲线
# ============================================
if os.path.exists('iteration_times.csv'):
    print("Plotting iteration times...")
    time_data = np.loadtxt('iteration_times.csv', delimiter=',', skiprows=1)
    iterations = time_data[:, 0]
    times = time_data[:, 1]

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(iterations, times, 'b-', linewidth=1.5, alpha=0.7)
    ax.set_xlabel('Iteration')
    ax.set_ylabel('Time (ms)')
    ax.set_title('Iteration Time vs Iteration Number')

    # 添加平均线
    avg_time = np.mean(times)
    ax.axhline(y=avg_time, color='r', linestyle='--', linewidth=2, label=f'Average: {avg_time:.2f} ms')
    ax.legend()

    plt.tight_layout()
    plt.savefig('iteration_times.jpg', format='jpg', bbox_inches='tight')
    plt.close()
    print("Saved: iteration_times.jpg")

# ============================================
# 5. 似然值变化曲线
# ============================================
if os.path.exists('likelihood_history.csv'):
    print("Plotting likelihood history...")
    like_data = np.loadtxt('likelihood_history.csv', delimiter=',', skiprows=1)
    iterations = like_data[:, 0]
    likelihoods = like_data[:, 1]

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(iterations, likelihoods, 'b-', linewidth=1.5, alpha=0.7)
    ax.set_xlabel('Iteration')
    ax.set_ylabel('Likelihood')
    ax.set_title('Likelihood History')
    ax.invert_yaxis()  # 似然越小越好，翻转y轴
    plt.tight_layout()
    plt.savefig('likelihood_history.jpg', format='jpg', bbox_inches='tight')
    plt.close()
    print("Saved: likelihood_history.jpg")

print("\n=== All plots generated successfully! ===")
print(f"Output directory: {output_dir}")
)";
        script.close();
        std::cout << "Saved Python plotting script to: " << script_path << std::endl;
        std::cout << "Run the script to generate plots:" << std::endl;
        std::cout << "  cd " << output_dir << " && python3 plot_results.py" << std::endl;
    }

    std::cout << "================================" << std::endl;
    return true;
}
